# CIS å®‰å…¨æœºåˆ¶æ¶æ„è®¾è®¡ï¼šæ ¸å¿ƒ vs Skill

## è®¾è®¡åŸåˆ™

**å®‰å…¨æœºåˆ¶å¿…é¡»åˆ†ä¸¤å±‚ï¼š**
1. **æ ¸å¿ƒå±‚ï¼ˆå¼ºåˆ¶ï¼‰**: TrustState æ£€æŸ¥ã€é€šä¿¡æ‹¦æˆª - ä¸å¯ç»•è¿‡
2. **Skill å±‚ï¼ˆå¯æ‰©å±•ï¼‰**: DID éªŒè¯æµç¨‹ã€å®‰å…¨ç­–ç•¥ - å¯è‡ªå®šä¹‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         åº”ç”¨å±‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  cis-node   â”‚  â”‚  cis-gui    â”‚  â”‚  ç¬¬ä¸‰æ–¹å®¢æˆ·ç«¯            â”‚  â”‚
â”‚  â”‚   (CLI)     â”‚  â”‚   (GUI)     â”‚  â”‚                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                â”‚                      â”‚                â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                          â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Security Skill (å¯æ’æ‹”)                      â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚ DID éªŒè¯æµç¨‹  â”‚  â”‚ å®‰å…¨ç­–ç•¥é…ç½®  â”‚  â”‚ å®¡è®¡æ—¥å¿—     â”‚   â”‚   â”‚
â”‚  â”‚  â”‚ - Challenge  â”‚  â”‚ - è‡ªåŠ¨éªŒè¯è§„åˆ™â”‚  â”‚ - äº‹ä»¶è®°å½•   â”‚   â”‚   â”‚
â”‚  â”‚  â”‚ - Response   â”‚  â”‚ - æ‹¦æˆªç­–ç•¥    â”‚  â”‚ - å‘Šè­¦é€šçŸ¥   â”‚   â”‚   â”‚
â”‚  â”‚  â”‚ - ç­¾åéªŒè¯   â”‚  â”‚ - è¶…æ—¶è®¾ç½®    â”‚  â”‚ - åˆ†ææŠ¥å‘Š   â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  æ¥å£: verify_peer(), get_security_policy(), log_event() â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                             â”‚                                    â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚                   â”‚                   â”‚               â”‚
â”‚         â–¼                   â–¼                   â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  CLI Hook   â”‚   â”‚  GUI Hook   â”‚   â”‚   Matrix Core       â”‚   â”‚
â”‚  â”‚  - å‘½ä»¤æ‹¦æˆª â”‚   â”‚  - äº‹ä»¶å¤„ç† â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  - çŠ¶æ€æ˜¾ç¤º â”‚   â”‚  - ç•Œé¢æ¸²æŸ“ â”‚   â”‚  â”‚ TrustState    â”‚  â”‚   â”‚
â”‚  â”‚  - äº¤äº’æµç¨‹ â”‚   â”‚  - å¯¹è¯æ¡†   â”‚   â”‚  â”‚ æ£€æŸ¥          â”‚  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚   â”‚
â”‚                                       â”‚  â”‚ é€šä¿¡æ‹¦æˆª      â”‚  â”‚   â”‚
â”‚                                       â”‚  â”‚ (ä¸å¯ç»•è¿‡)    â”‚  â”‚   â”‚
â”‚                                       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æ ¸å¿ƒå±‚ï¼ˆå¼ºåˆ¶ï¼‰è®¾è®¡

### æœ€å°æ ¸å¿ƒä¿®æ”¹

```rust
// cis-core/src/matrix/federation/types.rs

/// ä¿¡ä»»çŠ¶æ€ - æ ¸å¿ƒå±‚åªä¿ç•™çŠ¶æ€ï¼Œç­–ç•¥äº¤ç»™ Skill
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TrustState {
    Unknown,
    Pending { discovered_at: i64 },
    Verified { verified_at: i64, did: String },
    Blocked { blocked_at: i64 },  // æ ¸å¿ƒå±‚ä¸è®°å½•å…·ä½“åŸå› ï¼Œåªè®°å½•çŠ¶æ€
}

/// PeerInfo æ‰©å±• - æœ€å°åŒ–ä¿®æ”¹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerInfo {
    // ... åŸæœ‰å­—æ®µ ...
    pub trust_state: TrustState,
    pub expected_did: Option<String>,  // ç”¨äºéªŒè¯
}

impl PeerInfo {
    /// æ ¸å¿ƒå±‚ï¼šæ˜¯å¦å…è®¸é€šä¿¡ï¼ˆå¼ºåˆ¶æ£€æŸ¥ï¼‰
    pub fn can_communicate(&self) -> bool {
        matches!(self.trust_state, TrustState::Verified { .. })
    }
}
```

### é€šä¿¡æ‹¦æˆªï¼ˆæ ¸å¿ƒå±‚ï¼‰

```rust
// cis-core/src/matrix/federation/tunnel.rs

impl Tunnel {
    /// å‘é€äº‹ä»¶å‰å¼ºåˆ¶æ£€æŸ¥ - ä¸å¯ç»•è¿‡
    pub async fn send_event(&self, event: &CisMatrixEvent) -> Result<(), TunnelError> {
        // æŸ¥è¯¢ç›®æ ‡èŠ‚ç‚¹çš„ trust_state
        let peer = self.get_peer(&event.target).await?;
        
        if !peer.can_communicate() {
            // è®°å½•æ‹¦æˆªæ—¥å¿—
            tracing::warn!(
                "Event blocked: target={} state={:?}",
                event.target, peer.trust_state
            );
            
            return Err(TunnelError::TrustCheckFailed {
                target: event.target.clone(),
                state: peer.trust_state.clone(),
                // æä¾›è§£å†³æŒ‡å¼•
                help: format!(
                    "Node not verified. Run 'cis node verify {}' or use GUI to verify",
                    event.target
                ),
            });
        }
        
        // ç»§ç»­å‘é€...
        self.do_send_event(event).await
    }
}
```

---

## Security Skill è®¾è®¡

### Skill ç»“æ„

```rust
// skills/cis-security/src/lib.rs

use cis_core::skill::{Skill, SkillContext, Event};
use cis_core::matrix::federation::types::{PeerInfo, TrustState};

/// Security Skill - æä¾› DID éªŒè¯å’Œå®‰å…¨ç­–ç•¥
pub struct SecuritySkill {
    config: SecurityConfig,
    verifier: DidVerifier,
    audit_logger: AuditLogger,
}

impl SecuritySkill {
    /// éªŒè¯èŠ‚ç‚¹ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
    pub async fn verify_peer(
        &self,
        peer: &mut PeerInfo,
        options: VerifyOptions,
    ) -> Result<VerificationResult, SecurityError> {
        // 1. å‘é€ DID Challenge
        let challenge = self.create_challenge(&peer.server_name);
        
        // 2. ç­‰å¾… Responseï¼ˆå¸¦è¶…æ—¶ï¼‰
        let response = self.wait_for_response(&challenge, options.timeout).await?;
        
        // 3. éªŒè¯ç­¾å
        self.verifier.verify_signature(&challenge, &response)?;
        
        // 4. æ£€æŸ¥ DID åŒ¹é…
        if let Some(expected) = &peer.expected_did {
            if &response.did != expected {
                // DID ä¸åŒ¹é… - å¯èƒ½çš„æ”»å‡»
                self.audit_logger.log(SecurityEvent::DidMismatch {
                    peer: peer.server_name.clone(),
                    expected: expected.clone(),
                    actual: response.did.clone(),
                }).await;
                
                return Err(SecurityError::DidMismatch);
            }
        }
        
        // 5. æ›´æ–°çŠ¶æ€
        peer.trust_state = TrustState::Verified {
            verified_at: now(),
            did: response.did,
        };
        
        // 6. è®°å½•å®¡è®¡æ—¥å¿—
        self.audit_logger.log(SecurityEvent::VerificationSucceeded {
            peer: peer.server_name.clone(),
            did: response.did.clone(),
        }).await;
        
        Ok(VerificationResult::Success { did: response.did })
    }
    
    /// æ‹¦æˆªèŠ‚ç‚¹
    pub async fn block_peer(&self, peer: &mut PeerInfo, reason: BlockReason) {
        peer.trust_state = TrustState::Blocked {
            blocked_at: now(),
        };
        
        self.audit_logger.log(SecurityEvent::PeerBlocked {
            peer: peer.server_name.clone(),
            reason,
        }).await;
    }
    
    /// è·å–å®‰å…¨ç­–ç•¥
    pub fn get_policy(&self) -> SecurityPolicy {
        self.config.policy.clone()
    }
}

#[async_trait]
impl Skill for SecuritySkill {
    fn name(&self) -> &str { "cis_security" }
    
    async fn handle_event(&self, ctx: &dyn SkillContext, event: Event) -> Result<()> {
        match event {
            Event::Custom { name, data } => match name.as_str() {
                "security:verify_peer" => {
                    let peer_id = data.get("peer_id").as_str().unwrap();
                    let result = self.verify_peer(peer_id).await;
                    // å‘é€ç»“æœäº‹ä»¶
                    ctx.emit_event("security:verify_result", result)?;
                }
                "security:block_peer" => { ... }
                "security:get_policy" => { ... }
                _ => {}
            }
            _ => {}
        }
        Ok(())
    }
}
```

### Skill é…ç½®

```toml
# skills/cis-security/skill.toml
[skill]
name = "cis_security"
version = "0.1.0"
description = "DID verification and security policy enforcement"
auto_load = true  # å®‰å…¨ Skill é»˜è®¤è‡ªåŠ¨åŠ è½½

[config]
# éªŒè¯è¶…æ—¶ï¼ˆç§’ï¼‰
verify_timeout = 30

# è‡ªåŠ¨éªŒè¯ç­–ç•¥
[config.auto_verify]
enabled = false  # é»˜è®¤å…³é—­ï¼Œéœ€æ‰‹åŠ¨éªŒè¯
# å¯é…ç½®ä¸ºï¼šmdns_discovered = "pending", manual_add = "required"

# å®¡è®¡æ—¥å¿—
[config.audit]
enabled = true
storage = "local"  # local, sqlite, remote
retention_days = 90
```

---

## CLI é›†æˆæ–¹æ¡ˆ

### CLI å‘½ä»¤è®¾è®¡

```bash
# cis-node/src/commands/security.rs

/// å®‰å…¨ç›¸å…³å‘½ä»¤ - è°ƒç”¨ Security Skill
pub mod security {
    /// éªŒè¯èŠ‚ç‚¹
    pub async fn verify(peer_id: &str, opts: VerifyOptions) -> Result<()> {
        // è°ƒç”¨ Security Skill
        let skill = get_skill("cis_security")?;
        
        let result = skill.call("verify_peer", json!({
            "peer_id": peer_id,
            "expected_did": opts.expected_did,
            "timeout": opts.timeout,
        })).await?;
        
        // æ˜¾ç¤ºç»“æœ
        match result {
            Ok(verified) => {
                println!("âœ“ Node {} verified", peer_id);
                println!("  DID: {}", verified.did);
                println!("  Verified at: {}", verified.verified_at);
            }
            Err(e) => {
                println!("âœ— Verification failed: {}", e);
                if let Some(help) = e.help {
                    println!("  Help: {}", help);
                }
            }
        }
        
        Ok(())
    }
    
    /// æŸ¥çœ‹å®‰å…¨çŠ¶æ€
    pub async fn status(peer_id: Option<&str>) -> Result<()> {
        let store = get_federation_store()?;
        
        let peers = match peer_id {
            Some(id) => vec![store.get_peer(id)?],
            None => store.list_peers()?,
        };
        
        println!("{:<20} {:<12} {:<20}", "NODE", "STATE", "DETAILS");
        println!("{}", "-".repeat(60));
        
        for peer in peers {
            let (state_icon, details) = match &peer.trust_state {
                TrustState::Unknown => ("?", "Unknown".to_string()),
                TrustState::Pending { .. } => ("â—", "Verification pending".to_string()),
                TrustState::Verified { did, .. } => ("âœ“", format!("Verified: {}", did)),
                TrustState::Blocked { .. } => ("âœ—", "Blocked".to_string()),
            };
            
            println!("{:<20} {:<12} {:<20}", 
                peer.server_name, 
                state_icon,
                details
            );
        }
        
        Ok(())
    }
    
    /// æ‹¦æˆªèŠ‚ç‚¹
    pub async fn block(peer_id: &str, reason: &str) -> Result<()> {
        let skill = get_skill("cis_security")?;
        skill.call("block_peer", json!({
            "peer_id": peer_id,
            "reason": reason,
        })).await?;
        
        println!("âœ“ Node {} blocked", peer_id);
        Ok(())
    }
    
    /// åˆ—å‡ºå®¡è®¡æ—¥å¿—
    pub async fn audit_logs(filter: LogFilter) -> Result<()> {
        let skill = get_skill("cis_security")?;
        let logs = skill.call("get_audit_logs", json!({
            "filter": filter,
        })).await?;
        
        for log in logs {
            println!("[{}] {} - {:?}", log.timestamp, log.event_type, log.details);
        }
        
        Ok(())
    }
}
```

### CLI äº¤äº’æµç¨‹

```bash
# ç¤ºä¾‹ï¼šCLI éªŒè¯æµç¨‹

$ cis node list
NODE                 STATE    ADDRESS
desk-local           âœ“        192.168.1.100:6767
laptop-remote        â—        192.168.1.105:6767  # å¾…éªŒè¯

$ cis security verify laptop-remote
ğŸ” Verifying node "laptop-remote" at 192.168.1.105:6767...
ğŸ“¡ Sending DID Challenge...
â³ Waiting for response (timeout: 30s)...
âœ“ Signature verified
âœ“ DID matched: did:cis:laptop:abc123
âœ“ Node verified successfully!

$ cis node list
NODE                 STATE    ADDRESS
desk-local           âœ“        192.168.1.100:6767
laptop-remote        âœ“        192.168.1.105:6767  # å·²éªŒè¯

# ç°åœ¨å¯ä»¥é€šä¿¡äº†
$ cis message send laptop-remote "hello"
âœ“ Message sent
```

---

## è°ƒæ•´åçš„å¼€å‘è®¡åˆ’

### ä¼˜å…ˆçº§è°ƒæ•´

```
Phase 0: æ ¸å¿ƒå±‚æœ€å°ä¿®æ”¹ (1å¤©) â”€â”€â”€â”€â”
Phase 1: Security Skill (2å¤©) â”€â”€â”€â”€â”¼â”€â”€â”€ CLI å¯ç”¨ â”€â”€â”€â”
Phase 2: CLI é›†æˆ (1å¤©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”œâ”€â”€â”€ GUI é›†æˆ
Phase 3: GUI ç•Œé¢ (3å¤©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Phase 4: è¿œç¨‹ Agent (3å¤©)
Phase 5: æµ‹è¯• (2å¤©)
```

### æ–°ä»»åŠ¡æ‹†åˆ†

#### Phase 0: æ ¸å¿ƒå±‚æœ€å°ä¿®æ”¹ (1å¤©)

**Task 0.1: TrustState æ ¸å¿ƒæ•°æ®ç»“æ„ (0.5å¤©)**
- æ–‡ä»¶: `cis-core/src/matrix/federation/types.rs`
- å†…å®¹: æ·»åŠ  `TrustState` enum, `PeerInfo` æ‰©å±•
- å…³é”®: **æœ€å°ä¿®æ”¹**ï¼Œåªä¿ç•™çŠ¶æ€ï¼Œç­–ç•¥äº¤ç»™ Skill

**Task 0.2: æ ¸å¿ƒé€šä¿¡æ‹¦æˆª (0.5å¤©)**
- æ–‡ä»¶: `cis-core/src/matrix/federation/tunnel.rs`
- å†…å®¹: `send_event()` å‰æ·»åŠ  `can_communicate()` æ£€æŸ¥
- å…³é”®: **ä¸å¯ç»•è¿‡**ï¼Œè¿”å›æ˜ç¡®é”™è¯¯ä¿¡æ¯

#### Phase 1: Security Skill (2å¤©)

**Task 1.1: Security Skill æ¡†æ¶ (0.5å¤©)**
- æ–‡ä»¶: `skills/cis-security/src/lib.rs` (æ–°å»º)
- å†…å®¹: Skill ç»“æ„ï¼ŒåŸºæœ¬æ¥å£

**Task 1.2: DID éªŒè¯å®ç° (1å¤©)**
- æ–‡ä»¶: `skills/cis-security/src/verifier.rs`
- å†…å®¹: Challenge-Response, ç­¾åéªŒè¯

**Task 1.3: å®¡è®¡æ—¥å¿— (0.5å¤©)**
- æ–‡ä»¶: `skills/cis-security/src/audit.rs`
- å†…å®¹: äº‹ä»¶è®°å½•ï¼ŒæŸ¥è¯¢æ¥å£

#### Phase 2: CLI é›†æˆ (1å¤©)

**Task 2.1: CLI å®‰å…¨å‘½ä»¤ (0.5å¤©)**
- æ–‡ä»¶: `cis-node/src/commands/security.rs` (æ–°å»º)
- å†…å®¹: `cis security verify/status/block`

**Task 2.2: èŠ‚ç‚¹å‘½ä»¤é›†æˆ (0.5å¤©)**
- æ–‡ä»¶: `cis-node/src/commands/node.rs`
- å†…å®¹: `cis node list` æ˜¾ç¤º trust_state

---

## æ¶æ„ä¼˜åŠ¿

| æ–¹é¢ | æ ¸å¿ƒ+Skill æ¶æ„ | çº¯æ ¸å¿ƒæ¶æ„ |
|------|----------------|-----------|
| **æ¨¡å—åŒ–** | âœ… Skill å¯ç‹¬ç«‹å‡çº§ | âŒ éœ€è¦æ›´æ–°æ ¸å¿ƒ |
| **å¯å®šåˆ¶** | âœ… ç”¨æˆ·å¯æ›¿æ¢ Security Skill | âŒ å›ºå®šå®ç° |
| **å¼ºåˆ¶å®‰å…¨** | âœ… æ ¸å¿ƒå±‚æ‹¦æˆªä¸å¯ç»•è¿‡ | âœ… åŒæ ·å¯åšåˆ° |
| **CLI ä¼˜å…ˆ** | âœ… Skill æä¾› CLI æ¥å£ | âŒ CLI éœ€å•ç‹¬å®ç° |
| **ç”Ÿæ€æ‰©å±•** | âœ… ç¬¬ä¸‰æ–¹å¯å¼€å‘å®‰å…¨ç­–ç•¥ | âŒ åªæœ‰å®˜æ–¹å®ç° |

---

## æ¥å£å¥‘çº¦

### æ ¸å¿ƒå±‚ <-> Skill å±‚

```rust
// æ ¸å¿ƒå±‚æä¾›ï¼ˆåªè¯»ï¼‰
pub trait SecurityContext {
    fn get_peer(&self, id: &str) -> Option<PeerInfo>;
    fn list_peers(&self) -> Vec<PeerInfo>;
    fn update_trust_state(&self, id: &str, state: TrustState);
}

// Skill å±‚æä¾›
pub trait SecuritySkill {
    async fn verify_peer(&self, id: &str, opts: VerifyOptions) -> Result<VerificationResult>;
    async fn block_peer(&self, id: &str, reason: &str);
    async fn get_audit_logs(&self, filter: LogFilter) -> Vec<AuditLog>;
}
```

### CLI <-> Skill

```bash
# CLI è°ƒç”¨ Skill çš„æ¥å£
cis security <command> -> SecuritySkill::call(command, args)
```
